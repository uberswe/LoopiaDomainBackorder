name: Release

on:
  push:
    branches:
      - main
    tags:
      - 'v*' # Trigger on tags starting with 'v'
  workflow_dispatch: # Allow manual triggering

permissions:
  contents: write # Needed for creating releases

jobs:
  release:
    name: Build and Release
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for tags and branches
          token: ${{ secrets.GITHUB_TOKEN }} # Use the GitHub token for authentication
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          check-latest: true
      
      - name: Install dependencies for robotgo
        run: |
          sudo apt-get update
          sudo apt-get install -y libx11-dev xorg-dev libxtst-dev libpng-dev libxcb-xkb-dev libxkbcommon-dev libxkbcommon-x11-dev gcc-mingw-w64 gcc-multilib
      
      - name: Get version from source or tag
        id: get_version
        run: |
          # If triggered by a tag, use the tag name without the 'v' prefix
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "VERSION=$VERSION" >> $GITHUB_ENV
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "Version from tag: $VERSION"
          # If triggered by a push to main, extract version from main.go
          elif [[ $GITHUB_REF == refs/heads/main ]]; then
            # Extract Version from main.go
            VERSION=$(grep -oP 'Version = "\K[^"]+' cmd/loopiaDomainGrabber/main.go)
            echo "VERSION=$VERSION" >> $GITHUB_ENV
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            
            # Check if this version already has a tag
            if git rev-parse "v$VERSION" >/dev/null 2>&1; then
              echo "Tag v$VERSION already exists, skipping tag creation"
            else
              # Create a new tag for this release
              git config --local user.email "action@github.com"
              git config --local user.name "GitHub Action"
              git tag -a "v$VERSION" -m "Release v$VERSION"
              echo "Created new tag: v$VERSION"
              
              # Push the tag to the repository
              git push origin "v$VERSION"
            fi
            echo "Version from code: $VERSION"
          else
            # If manually triggered, generate a version based on the latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            LATEST_VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
            echo "VERSION=$NEW_VERSION" >> $GITHUB_ENV
            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            # Create a new tag for this release
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
            echo "Generated new version: $NEW_VERSION"
            
            # Push the tag to the repository
            git push origin "v$NEW_VERSION"
          fi
      
      - name: Get commit hash
        id: get_commit_hash
        run: |
          COMMIT_HASH=$(git rev-parse --short HEAD)
          echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
      
      - name: Get build date
        id: get_build_date
        run: |
          BUILD_DATE=$(date -u +"%Y-%m-%d")
          echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
      
      - name: Build for multiple platforms
        run: |
          # Create a directory for the binaries
          mkdir -p dist
          
          # Build for Linux (amd64)
          GOOS=linux GOARCH=amd64 go build -ldflags="-X 'main.Version=${{ env.VERSION }}' -X 'main.Commit=${{ env.COMMIT_HASH }}' -X 'main.BuildDate=${{ env.BUILD_DATE }}'" -o dist/loopiaDomainGrabber-linux-amd64 ./cmd/loopiaDomainGrabber
          
          # Build for macOS (amd64)
          GOOS=darwin GOARCH=amd64 go build -ldflags="-X 'main.Version=${{ env.VERSION }}' -X 'main.Commit=${{ env.COMMIT_HASH }}' -X 'main.BuildDate=${{ env.BUILD_DATE }}'" -o dist/loopiaDomainGrabber-darwin-amd64 ./cmd/loopiaDomainGrabber
          
          # Build for macOS (arm64)
          GOOS=darwin GOARCH=arm64 go build -ldflags="-X 'main.Version=${{ env.VERSION }}' -X 'main.Commit=${{ env.COMMIT_HASH }}' -X 'main.BuildDate=${{ env.BUILD_DATE }}'" -o dist/loopiaDomainGrabber-darwin-arm64 ./cmd/loopiaDomainGrabber
          
          # Build for Windows (amd64)
          GOOS=windows GOARCH=amd64 go build -ldflags="-X 'main.Version=${{ env.VERSION }}' -X 'main.Commit=${{ env.COMMIT_HASH }}' -X 'main.BuildDate=${{ env.BUILD_DATE }}'" -o dist/loopiaDomainGrabber-windows-amd64.exe ./cmd/loopiaDomainGrabber
          
          # Create zip archives for each binary
          cd dist
          zip -r loopiaDomainGrabber-linux-amd64.zip loopiaDomainGrabber-linux-amd64
          zip -r loopiaDomainGrabber-darwin-amd64.zip loopiaDomainGrabber-darwin-amd64
          zip -r loopiaDomainGrabber-darwin-arm64.zip loopiaDomainGrabber-darwin-arm64
          zip -r loopiaDomainGrabber-windows-amd64.zip loopiaDomainGrabber-windows-amd64.exe
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Release v${{ env.VERSION }}
          tag_name: v${{ env.VERSION }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            dist/loopiaDomainGrabber-linux-amd64.zip
            dist/loopiaDomainGrabber-darwin-amd64.zip
            dist/loopiaDomainGrabber-darwin-arm64.zip
            dist/loopiaDomainGrabber-windows-amd64.zip